//! Traits for handlers.
//!
//! Each rotor machine provided by the netmachines crate uses a number of
//! *handler types* to perform the actual work. There are three categories
//! of handler types, each defined by the handler trait it has to implement:
//! an [AcceptHandler] is used by machines listening for incoming
//! [stream][Stream] connections, a [RequestHandler] is used by client
//! machines to translate client requests into
//! [transports sockets][Transport], and a [TransportHandler] implements the
//! behaviour of such transport sockets. 
//!
//! [AcceptHandler]: trait.AcceptHandler.html
//! [RequestHandler]: trait.RequestHandler.html
//! [TransportHandler]: trait.TransportHandler.html
//! [Stream]: ../sockets/trait.Stream.html
//! [Transport]: ../sockets/trait.Transport.html

use std::net::SocketAddr;
use rotor::Notifier;
use ::error::Error;
use ::next::Next;


//------------ AcceptHandler -------------------------------------------------

/// The trait implemented by an accept handler.
///
/// An accept handler is used by strem servers to process incoming
/// connection requests. For each request, the [accept()](#tymethod.accept)
/// method is called once.
///
/// Note that trait is generic over the transport socket `T` used by the
/// connections created by accepting, not the accept socket.
pub trait AcceptHandler<T> {
    /// The transport handler ultimately created when accepting a connection. 
    type Output: TransportHandler<T>;

    /// Accepts an incoming connection request.
    ///
    /// The `addr` argument contains the peer address of the incoming request.
    ///
    /// The method can decide whether to accept the request or not. If it
    /// returns `None`, the connection is closed cleanly immediately.
    /// Otherwise, the method returns the seed for the transport handler to
    /// be created for processing the connection. See the discussion of how
    /// transport handlers are created at the [TransportHandler] trait.
    ///
    /// [TransportHandler]: trait.TransportHandler.html
    fn accept(&mut self, addr: &SocketAddr)
              -> Option<<Self::Output as TransportHandler<T>>::Seed>;
}


//------------ RequestHandler ------------------------------------------------

/// The trait implemented by a request handler.
///
/// Request handlers are the entry point from the rest of the program into
/// the networking layer; a *request* in this sense is something the program
/// wants the network stack to do, not a request received on the network.
/// They are commonly used in a client scenario where the application acts
/// as a network client to various servers.
///
/// The application sends a request to a request queue which is picked up
/// by the state machines and passed to the request handler for processing
/// via the [request()](#tymethod.request) method. This method produces
/// some output, the type of which depends on the client machinery in
/// question. It generally is a pair of a socket address and the seed of
/// the transport handler. The pair is used to create a socket connecting
/// to the given address and a transport handler for the socket.
///
/// If creating the socket or connecting fails, the [error()](#tymethod.error)
/// is called so you can deal with the failure.
pub trait RequestHandler {
    /// The type representing a request.
    type Request: Send;

    /// The output type produced by the handler.
    ///
    /// This type must match the client machine the handler is used for.
    type Output;

    /// Processes an incoming request.
    ///
    /// The method can decide whether the request requires a new socket or
    /// can be satisfied in other ways. If the method returns `None`,
    /// nothing further happens. If it, however, returns `Some(_)`, the
    /// client machine will use this information to create both a socket
    /// and a transport handler.
    fn request(&mut self, request: Self::Request) -> Option<Self::Output>;

    /// Handles an error that happened during socket creation.
    ///
    /// The `output` argument will contain the output generated by the
    /// [request()](#tymethod.request) method. The `err` argument is the
    /// error that happened while creating a socket for the output.
    ///
    /// The default implementation does nothing.
    fn error(&mut self, output: Self::Output, err: Error) {
        // Underscores in argument names look bad in documentation ...
        let _ = (output, err);
    }
}


//------------ TransportHandler ----------------------------------------------

/// The trait implemented by a transport handler.
///
/// A transport handler is operating a transport socket, ie., any socket
/// over which data is sent and received. The particular type of socket is
/// stated through the type argument `T`. You can choose which socket you
/// want to be able to handle by giving a bound for `T`. Traits to choose
/// from are defined in the [sockets] module.
///
/// The transport handler reacts to various events happening on the socket
/// in the various methods. Most of these methods are used in the same way:
/// ownership of the handler is transfered into the method, allowing it to
/// do whatever it wants to do to it. Once done, it returns a [Next<Self>].
/// This type provides both a new handler as well as the events on the
/// socket this new handler is interested. In its most simple form, the
/// method could simply reuse the old handler by, for instance, simply
/// returning `Next::read(self)`. There is one special case:
/// `Next::remove()` doesn’t take an argument and means that the handler is
/// done.
///
/// Transport handlers are created in a somewhat peculiar way. The trait
/// contains the [create()](#tymethod.create) function which creates a new
/// handler from something called a *seed,* a separate type containing all
/// information a new handler needs to start its work.
/// [Accept handlers][AcceptHandler] return such a seed for connections
/// accepted from listening sockets in servers,
/// [Request handlers][RequestHandler] for sockets to be created for
/// requests.
///
/// The main reason for choosing this approach is that many transport
/// handlers have to rely on work done elsewhere and have to wait for the
/// results of this work to return. They do so by returning
/// `Next::wait(self)` which indicates interest neither in reading or
/// writing. However, the [create()](#tymethod.create) function receives
/// a notifier which can be used to wake up the handler again--its
/// [wakeup()](#tymethod.wakeup) will then be called. The [sync] module
/// provides some synchronization types that use this notifier.
///
/// Unfortunately, the notifier is only available after the underlying
/// rotor state machine has already been created which only happens after,
/// for instance, the accept handler has returned. So, if the transport
/// handler were to be created in the accept handler, it couldn’t receive
/// the notifier yet and would have to resort to an `Option<_>` to keep a
/// spot open for it which would make the logic later on unnecessarily
/// complicated.
///
/// Which, conversely, means that if your transport handler doesn’t need
/// the notifier it doesn’t really need all the seed shenanigans either.
/// In this case it can simply be its own seed: the accept or request
/// handler can create and return a transport handler which has
/// `type Seed = Self` and whose `create()` simply returns whatever it
/// wants next.
/// 
/// [AcceptHandler]: trait.AcceptHandler.html
/// [Next<Self>]: ../next/struct.Next.html
/// [RequestHandler]: trait.RequestHandler.html
/// [sockets]: ../sockets/index.html
/// [sync]: ../sync/index.html
pub trait TransportHandler<T>: Sized {
    /// The type holding all information necessary to create a handler.
    ///
    /// See the discussion about handler creating above.
    type Seed;

    /// Creates a new transport handler from a seed.
    ///
    /// The `sock` argument contains a reference to the actual socket the
    /// handler will operate on. There is no need to keep that socket or
    /// the reference, you’ll receive it later on again.
    ///
    /// The `notifier` argument contains a notifier for waking up the
    /// handler. You can keep that or give it away (or both, a notifier
    /// is `Clone`). Most likely, though, you will want to create a
    /// [synchronization type][sync] from it.
    ///
    /// The method ought to return the new handler wrapped into what should
    /// happen next. You are free to choose any variant, even
    /// `Next::remove()` which would lead to instant dropping of the new
    /// socket.
    ///
    /// [sync]: ../sync/index.html
    fn create(seed: Self::Seed, sock: &mut T, notifier: Notifier)
              -> Next<Self>;

    /// Called when the socket may have become readable.
    ///
    /// This does not necessarily mean that reading from the socket will
    /// succeed. There may be circumstances where a socket signalled as
    /// readable is otherwise busy. If this happens, a read attempt will
    /// result in a `WouldBlock` error which is signalled differently by
    /// different socket types. It is very important to treat this case
    /// correctly and be prepared for it at all times.
    ///
    /// A reference to the socket is provided in the `sock` argument.
    fn readable(self, sock: &mut T) -> Next<Self>;

    /// Called when the socket may have become writable.
    ///
    /// A reference to the socket is provided in the `sock` argument.
    ///
    /// The caveats noted for reading in [readable()](#tymethod.readable)
    /// above equally apply to writing.
    fn writable(self, sock: &mut T) -> Next<Self>;

    /// Called upon wakeup via a notifier.
    ///
    /// The method is called once for every time the notifier’s `wakeup()`
    /// method has been successfully called. It will be called irregardless
    /// of the events requested. You do not have to call `Next::wait()` in
    /// order to being woken up.
    fn wakeup(self) -> Next<Self>;

    /// Called when an error has occured on the socket.
    ///
    /// You are free to signal any next value here, though most likely
    /// `Next::remove()` is the safest choice. This is exactly what the
    /// default implementation does.
    ///
    /// Note that if a timeout is installed using `Next::timeout()` and this
    /// timeout passes, this is signalled as an `Error::Timeout` error and
    /// thus will result in this method being called.
    fn error(self, err: Error) -> Next<Self> {
        let _ = err;
        Next::remove()
    }
}

